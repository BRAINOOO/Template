/*
explantion :

1- here KMP is for finding a pattern( substring ) in a string in an efficient way.
2- if you tried to do so using brude force approach it will cost n*m (n is the length of string and m is the length of the pattern) which
is bad complexity.
3- some helpful terminalogy

     1- Proper Prefix List (PPL): eg for the string " abcdr " is "a" , "ab", "abc" ,"abcd" only not containing the whole string but the 
     normal prefix is the previous plus "abcdr" containing the whole string.
   
     2- Proper Suffix List (PSL): eg for the string " abcdr " is "r" , "dr", "cdr" ,"bcdr" only not containing the whole string but the 
     normal suffix is the previous plus "abcdr" containing the whole string.
     
 4- Failure Function OR Prefix function : it expresses the longest common proper prefix and suffix for eg " aabaab "
 
 F[0] always equals to zero
 F[1]=1 prefix 'a'  and suffix 'a'
 F[2]=0
 F[3]=1 prefix 'a'  and suffix 'a'
 F[4]=2 prefix 'aa'  and suffix 'aa'
 F[5]=3 prefix 'aab'  and suffix 'aab'
 
 5- KMP algorithsm based on 
 
 the fact that when i brudeforce i will start from each index in the main string and check for the length of the pattern and once i fail
 i will go back and start from the next index so there is kind of repition, I can start from the next index only if my pattern is for eg
 like this aaaa so Failture function equals to 3 here y3ny from here its idea comes.
 
6- Complexity for KMP is O(n) n is size of main string and failture function is O(m) m is the length of the pattern so total is O( n+m )

7- Failture function implementation :
  the same idea of KMP i will try to match the prefix of the pattern with the pattern itself.
  
 --------------------------CODE OF KMP------------------------
 
 void KMP(string str,string pat)
{
    
    int n=sz(str);
    int m=sz(pat);
    
    vector<int> longestprefix= computeprefix(pat);
    
    for(int i=0,k=0;i<n;i++)
    {
        while(k>0&&pat[k]!=str[i])
            k=longestprefix[k-1];
        
        if(pat[k]==str[i])
            k++;
        if(k==m)
        {
            cout<<i-m+1<<endl;    // begining index of the first match
            k=longestprefix[k-1];
        }
    }
}

---------------------Failure Function------------------------------

void computeprefix(string pat)
{
    int m=sz(pat);
    vector<int> longestprefix(m);

    for(int i=1,k=0;i<n;i++)   // i from 1 bec F[0]=0
    {
        while(k>0&&pat[k]!=pat[i])
            k=longestprefix[k-1];
        
        if(pat[k]==pat[i])
           longestprefix[i]= ++k;
        else
            longestprefix[i]=k;
        
    }
    
    return longestprefix;
}
  
----------------------------------------------------------------------------------------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
